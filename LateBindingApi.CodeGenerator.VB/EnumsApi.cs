using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using System.Text;

namespace LateBindingApi.CodeGenerator.VB
{
    internal static class EnumsApi
    {
        private static string _fileHeader = "'Generated by LateBindingApi.CodeGenerator\r\n"
                                            + "Imports System\r\n"
                                            + "Imports NetOffice\r\n"
                                            + "Namespace %namespace%\r\n"
                                            + "\r\n";

        internal static string ConvertEnumsToFiles(XElement projectNode, XElement enumsNode, Settings settings, string solutionFolder)
        {
            string enumFolder = System.IO.Path.Combine(solutionFolder, projectNode.Attribute("Name").Value);
            enumFolder = System.IO.Path.Combine(enumFolder, "Enums");
            if (false == System.IO.Directory.Exists(enumFolder))
                System.IO.Directory.CreateDirectory(enumFolder);
            
            string result = "";
            foreach (XElement enumNode in enumsNode.Elements("Enum"))
                result += ConvertEnumToFile(settings, projectNode, enumNode, enumFolder) + "\r\n";

            return result;
        }

        private static string ConvertEnumToFile(Settings settings, XElement projectNode, XElement enumNode, string enumFolder)
        {
            string fileName = System.IO.Path.Combine(enumFolder, enumNode.Attribute("Name").Value + ".vb");

            string newEnum = ConvertEnumToString(settings, projectNode, enumNode);
            System.IO.File.AppendAllText(fileName, newEnum);

            int i = enumFolder.LastIndexOf("\\");
            string result = "\t\t<Compile Include=\"" + enumFolder.Substring(i + 1) + "\\" + enumNode.Attribute("Name").Value + ".vb" + "\" />";
            return result;
        }

        private static string ConvertEnumToString(Settings settings, XElement projectNode, XElement enumNode)
        {
            string result = _fileHeader.Replace("%namespace%", projectNode.Attribute("Namespace").Value + ".Enums");
            string enumAttributes = VBGenerator.GetSupportByVersionAttribute(enumNode);

            string name = enumNode.Attribute("Name").Value;


            if (true == settings.CreateXmlDocumentation)
                result += VBGenerator.GetSupportByVersionSummary("\t", enumNode);

            result += "\t" + enumAttributes + Environment.NewLine;
            result += "\t<EntityTypeAttribute(EntityType.IsEnum)> _\r\n";
            result += "\tpublic Enum " + name + Environment.NewLine + "\t" + Environment.NewLine;

            int countOfMembers =  enumNode.Element("Members").Elements("Member").Count();
            int i = 1;
            foreach (var itemMember in enumNode.Element("Members").Elements("Member"))
            {
                string memberAttribute = VBGenerator.GetSupportByVersionAttribute(itemMember);
                string memberName = itemMember.Attribute("Name").Value;
                string memberValue = itemMember.Attribute("Value").Value;

                if (true == settings.CreateXmlDocumentation)
                {
                    result += VBGenerator.GetSupportByVersionSummary("\t\t", itemMember);
                    result += "\t\t ''' <remarks>" + memberValue + "</remarks>\r\n";
                }

                result += "\t\t " + memberAttribute + "\r\n";
                result += "\t\t " + ParameterApi.ValidateName(memberName) + " = " + memberValue;
                result += "\r\n\r\n";
                
                i++;
            }
            
            result += "\tEnd Enum\r\n" + Environment.NewLine;
            result += "End Namespace";
            return result;
        }
    }
}
